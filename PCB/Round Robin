#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct PCB {
    int process_id;
    char state[20];
    int priority;
    unsigned int pc;
    int registers[8];
    int base_address;
    int limit;
    int arrival_time;
    int burst_time;
    int remaining_time;
    int wait_time;
    int turnaround_time;
    struct PCB *next;
} PCB;

typedef struct ReadyQueue {
    PCB *head;
    PCB *tail;
} ReadyQueue;

typedef struct IOQueue {
    PCB *head;
    PCB *tail;
} IOQueue;

// Function to initialize a PCB
PCB* create_pcb(int id, int priority, int arrival_time, int burst_time, int base_address, int limit) {
    PCB *new_pcb = (PCB *)malloc(sizeof(PCB));
    if (new_pcb == NULL) {
        fprintf(stderr, "Memory allocation failed for PCB.\n");
        exit(EXIT_FAILURE);
    }
    new_pcb->process_id = id;
    strcpy(new_pcb->state, "Ready");
    new_pcb->priority = priority;
    new_pcb->pc = 0;
    memset(new_pcb->registers, 0, sizeof(new_pcb->registers));
    new_pcb->base_address = base_address;
    new_pcb->limit = limit;
    new_pcb->arrival_time = arrival_time;
    new_pcb->burst_time = burst_time;
    new_pcb->remaining_time = burst_time;
    new_pcb->wait_time = 0;
    new_pcb->turnaround_time = 0;
    new_pcb->next = NULL;
    return new_pcb;
}

// Enqueue function for Ready Queue with priority handling
void priority_enqueue(ReadyQueue *queue, PCB *process) {
    if (queue->head == NULL || queue->head->priority < process->priority) {
        process->next = queue->head;
        queue->head = process;
        if (queue->tail == NULL) queue->tail = process;
    } else {
        PCB *current = queue->head;
        while (current->next != NULL && current->next->priority >= process->priority) {
            current = current->next;
        }
        process->next = current->next;
        current->next = process;
        if (current == queue->tail) queue->tail = process;
    }
}

// Dequeue function for Ready Queue
PCB* dequeue(ReadyQueue *queue) {
    if (queue->head == NULL) return NULL;
    PCB *process = queue->head;
    queue->head = queue->head->next;
    if (queue->head == NULL) queue->tail = NULL;
    return process;
}

// Enqueue function for I/O Queue
void io_enqueue(IOQueue *queue, PCB *process) {
    if (queue->tail == NULL) {
        queue->head = queue->tail = process;
    } else {
        queue->tail->next = process;
        queue->tail = process;
    }
    process->next = NULL;
}

// Dequeue function for I/O Queue
PCB* io_dequeue(IOQueue *queue) {
    if (queue->head == NULL) return NULL;
    PCB *process = queue->head;
    queue->head = queue->head->next;
    if (queue->head == NULL) queue->tail = NULL;
    return process;
}

// Check I/O Queue for completed processes
void check_io_queue(IOQueue *io_queue, ReadyQueue *ready_queue, int current_time) {
    PCB *prev = NULL, *current = io_queue->head;
    while (current != NULL) {
        if (rand() % 2 == 0) { // Simulate I/O completion (50% chance per tick)
            printf("Time %d: Process %d completed I/O\n", current_time, current->process_id);
            if (prev == NULL) {
                io_queue->head = current->next;
            } else {
                prev->next = current->next;
            }
            if (current == io_queue->tail) io_queue->tail = prev;

            PCB *completed_io = current;
            current = current->next;
            priority_enqueue(ready_queue, completed_io);
        } else {
            prev = current;
            current = current->next;
        }
    }
}

// Round Robin Scheduler with priority and I/O integration
void round_robin(ReadyQueue *queue, IOQueue *io_queue, int quantum) {
    int current_time = 0;
    while (queue->head != NULL || io_queue->head != NULL) {
        check_io_queue(io_queue, queue, current_time);

        PCB *current_process = dequeue(queue);
        if (current_process == NULL) {
            printf("Time %d: CPU idle\n", current_time);
            current_time++;
            continue;
        }

        printf("Time %d: Running process %d\n", current_time, current_process->process_id);
        if (current_process->remaining_time <= quantum) {
            current_time += current_process->remaining_time;
            current_process->remaining_time = 0;
            current_process->turnaround_time = current_time - current_process->arrival_time;
            current_process->wait_time = current_process->turnaround_time - current_process->burst_time;
            printf("Time %d: Process %d completed. Turnaround Time: %d, Wait Time: %d\n",
                   current_time, current_process->process_id, current_process->turnaround_time, current_process->wait_time);
            free(current_process); // Process is done, release memory
        } else {
            current_time += quantum;
            current_process->remaining_time -= quantum;

            if (rand() % 4 == 0) { // Simulate I/O request (25% chance)
                printf("Time %d: Process %d performing I/O\n", current_time, current_process->process_id);
                io_enqueue(io_queue, current_process);
            } else {
                priority_enqueue(queue, current_process);
            }
        }
    }
}

// Main function to test the scheduler
int main() {
    srand(time(NULL)); // Seed for random I/O simulation

    ReadyQueue ready_queue = {NULL, NULL};
    IOQueue io_queue = {NULL, NULL};
    int quantum = 4; // Time slice

    // Create some processes with priorities
    priority_enqueue(&ready_queue, create_pcb(1, 3, 0, 10, 1000, 2000));
    priority_enqueue(&ready_queue, create_pcb(2, 1, 2, 5, 2000, 1000));
    priority_enqueue(&ready_queue, create_pcb(3, 2, 4, 8, 3000, 1500));

    // Run the scheduler
    round_robin(&ready_queue, &io_queue, quantum);

    return 0;
}
