#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define FRAME_SIZE 4096
#define NUM_FRAMES 4 // Physical memory frames
#define MAX_PAGES 32 // Maximum virtual memory pages

typedef struct Frame {
    int process_id;   // ID of the process using the frame
    int page_number;  // Page number mapped to this frame
} Frame;

typedef struct PCB {
    int process_id;
    int page_table[MAX_PAGES]; // Maps virtual pages to frames
} PCB;

// Global memory simulation
Frame physical_memory[NUM_FRAMES];
int clock_time = 0; // Simulated time for FIFO tracking

// Initialize physical memory
void initialize_memory() {
    for (int i = 0; i < NUM_FRAMES; i++) {
        physical_memory[i].process_id = -1; // free frame
        physical_memory[i].page_number = -1;
    }
}

// Allocate a page to a process
int allocate_page(PCB *pcb, int page_number) {
    // Search for a free frame
    for (int i = 0; i < NUM_FRAMES; i++) {
        if (physical_memory[i].process_id == -1) { // Free frame found
            // Assign frame to the process
            physical_memory[i].process_id = pcb->process_id;
            physical_memory[i].page_number = page_number;
            pcb->page_table[page_number] = i;
            printf("Allocated page %d of process %d to frame %d\n",
                   page_number, pcb->process_id, i);
            return 1;
        }
    }

    // Memory full, page replacement needed
    return 0;
}

// FIFO Page Replacement
void fifo_page_replacement(PCB *pcb, int page_number) {
    static int next_frame = 0; // Points to the next frame to be replaced

    printf("Page replacement (FIFO): Replacing frame %d (Process %d, Page %d)\n",
           next_frame, physical_memory[next_frame].process_id,
           physical_memory[next_frame].page_number);

    // Replace the frame
    physical_memory[next_frame].process_id = pcb->process_id;
    physical_memory[next_frame].page_number = page_number;
    pcb->page_table[page_number] = next_frame;

    next_frame = (next_frame + 1) % NUM_FRAMES; // Move to the next frame
}

// Handle a memory request
void request_memory(PCB *pcb, int page_number) {
    // Check if the page is already in memory
    if (pcb->page_table[page_number] != -1) {
        int frame = pcb->page_table[page_number];
        printf("Page %d of process %d is already in frame %d\n",
               page_number, pcb->process_id, frame);
        return;
    }

    printf("Page fault for page %d of process %d\n", page_number, pcb->process_id);

    // Attempt to allocate the page
    if (!allocate_page(pcb, page_number)) {
        // Perform FIFO page replacement
        fifo_page_replacement(pcb, page_number);
    }
}

// Demo Function
void demo_memory_management() {
    PCB pcb1 = {1, {-1}};                            // Initialize page table with -1

    // Simulate memory requests
    request_memory(&pcb1, 0);
    request_memory(&pcb1, 1);
    request_memory(&pcb1, 2);
    request_memory(&pcb1, 3);
    request_memory(&pcb1, 0);
    request_memory(&pcb1, 4);

    printf("Demo complete.\n");
}

// Main Function
int main() {
    initialize_memory();

    printf("=== FIFO Page Replacement Demo ===\n");
    demo_memory_management();

    return 0;
}
